= 锁

== 表锁

== 行锁

=== 行锁优化

尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
合理设计索引，尽量缩小锁的范围
尽可能减少检索条件，避免间歇锁
尽量控制事务大小，减少锁定资源量和时间长度
尽可能低级别事务隔离

== 间隙锁

当我们用范围条件而不是eq条件查询数据，并请求共享或者排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；
对于键值在条件范围内但并不存在的记录，叫“间隙（GAP）” InnoDB也会对这个”间隙“加锁，这种锁机制是所谓的间隙锁（Next-Key锁）

== 页锁

开销和加锁时间界于表锁和行锁之间，颗粒度同样，会出现死锁，并发度一般；

== 死锁

[sql]
....
show status like 'innodb_row_lock%';
....

== 附录

* https://juejin.cn/post/6937150983210450957?utm_source=gold_browser_extension[一文带你读懂MySQL锁机制]