= 锁
> 锁是一种计算机协调进程或者线程并发访问某一资源的机制

== 锁的分类
* 读锁（共享锁）：多个读操作可以同时进行
* 写锁（排他锁）：写操作完成前，会阻塞其他的读锁和写锁

== 锁的粒度

|===
|粒度|存储引擎代表|开销(相对)|是否导致死锁|并发度

|表锁
|MyISAM
|小
|否
|最低

|行锁
|InnoDB
|大
|是
|最高

|页锁
|
|中
|是
|一般
|===

=== 表锁
==== 自增锁
一种特殊的表锁，当表中设置有自增 **auto_increment**列，在Insert数据时会先获取自增锁，其他事物的Insert操作将会被阻塞，自增列+1后释放，如果事物回滚，自增值也不会回滚，所以自增列并不一定是连续自增。

5.1.22版本开始，引入了一种可选轻量级锁**mutex**机制来代替AUTOINC锁。

==== 元数据锁(Metadata Lock)

从MySQL 5.5版本开始引入MDL锁，来保护表的元数据信息，用于解决或者保证DDL操作与DML操作之间的一致性。

其主要解决了2个问题:

* 事物隔离问题: 比如可重复隔离级别下，会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致，无法满足可重复度的要求
* 数据复制问题: 比如会话A执行了多条更新语句期间，另外一个会话B做了表结构变更并且先他提交，就会导致slave在重做是，先重做alter，再重做update时，就会出现复制错误的现象。

一旦出现MDL写锁等待，不但会阻塞当前操作，同时还会阻塞后续该表的所有操作（MySQL 5.6推出了online ddl机制，对排队的MDL写锁进行降级，防止对MDL读锁的阻塞）。

=== 行锁
==== 记录锁(Record Lock)

记录锁在唯一索引列或者主键列记录上加锁，且该值存在，否则加锁类型为记录锁。

==== 间隙锁(Gap Lock)

当我们用范围条件而不是eq条件查询数据，并请求共享或者排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；

对于键值在条件范围内但并不存在的记录，叫“间隙（GAP）” InnoDB也会对这个”间隙“加锁，这种锁机制是所谓的间隙锁（Next-Key锁）

===== 插入意向锁(Insert Intention Locks)

是一种特殊的间隙锁,只有在Insert操作时才会加锁，插入意向锁之间不冲突，可以向一个间隙同时插入多行数据，但插入意向锁和间隙锁是冲突的，当有间隙锁存在Insert操作将被阻塞，正是这个特性解决了幻读的问题。

==== 临键锁(Next-Key Lock)

临键锁是记录锁和间隙锁的合集，只可在可重复读、串行化两个隔离级别才有。


==== 意向锁
意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示”某个事物正在某一行持有了锁，或者准备去持有锁“，避免加表锁之前去表中查找记录是否上锁。

==== 行锁优化

* 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
+
为没有索引的字段加锁，会导致升级为表锁；范围性加锁，需要加锁的数据过多，mysql认为开销过大也会升级为表锁；
* 合理设计索引，尽量缩小锁的范围
* 尽可能减少检索条件，避免间歇锁
* 尽量控制事务大小，减少锁定资源量和时间长度
+
也有可能多次加锁的效率低于加一个大的锁
* 尽可能低级别事务隔离

=== 页锁

=== 加锁时机



== 死锁

并发环境的通病死锁


== 分析
[sql]
....
show status like 'innodb_row_lock%';

Innodb_row_lock_current_waits：当前正在等待锁定的数量；
Innodb_row_lock_time：从系统启动到现在锁定总时间长度；
Innodb_row_lock_time_avg：每次等待所花平均时间；
Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
Innodb_row_lock_waits：系统启动后到现在总共等待的次数；
....

== 附录

* https://juejin.cn/post/6937150983210450957?utm_source=gold_browser_extension[一文带你读懂MySQL锁机制]
* https://cloud.tencent.com/developer/article/1839590[一文理解MySQL的锁机制与死锁排查]