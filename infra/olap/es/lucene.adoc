= Lucene

索引原理：

. 词典
.. 采用
. 倒排表
. 正向文件
.. 正向文件指的就是原始文档，Lucene对原始文档也提供了存储功能，它存储特点就是分块+压缩，fdt文件就是存放原始文档的文件，它占了索引库90%的磁盘空间，fdx文件为索引文件，通过文档号（自增数字）快速得到文档位置。
. 列式存储DocValues
.. 我们知道倒排索引能够解决从词到文档的快速映射，但当我们对检索结果进行分类、排序、数学计算等聚合操作时需要文档号等值得快速映射，而原先不管是倒排索引还是行式存储的文档都无法满足要求。
.. 原先4.0版本之前，Lucene实现这种需求是通过Fieldcache，它的原理是通过按列逆转倒排表将（field value -> doc）映射变成（doc-> field value）映射，但这种实现方法有两个显著问题：
... 构建时间长
... 内存占用大，易OOM，且影响垃圾回收
.. 4.0之后退出来Docvalues来解决这个问题，它和FieldCache一样都是列式存储，但它有如下优点：
... 预先构建，写入文件。
... 基于映射文件来做，脱离JVM堆内存，系统调度缺页。
... DocValues这种实现方法只比内存Fieldcache慢大概10~25%但稳定性却得到了极大提升,目前有5种类型的Docvalues： NUMERIC、BINARY、SORTED、SORTED_SET、SORTED_NUMERIC
... 对DocValues的应用，ES功能实现地更系统，更完整，即Agg聚合功能，它的聚合功能分为三类：
.... Metric -> 统计： 典型功能：sum、min、max、avg、cardinality、percent等
.... Bucket -> 分组： 典型功能： 日期直方图，分组，地理位置分组
.... Pipline -> 基于聚合再聚合： 典型功能：基于各分组的平均值求最大值



|===
| 数据结构| 优缺点
| 排序列表
| 实现简单，但性能差

| 哈希表
|性能高，内存消耗大

| 跳跃表
| 占用内存小，且可调，但对模糊查询支持不好（lucene3.0之前使用，后换为FST，但跳跃表在Lucene其他地方还有应用如倒排表合并和文档号索引）

| B树
| 磁盘索引，更新方便，但检索速度慢，数据库应用较多

| 字典数
| 查询效率只跟字符串长度有关，但只是和英文词典

| 双数组字典树
| 可做中文词典，内存占用小，分词工具应用较多

| Finite State Transducers（FST）
| 共享前缀，内存消耗小，但要求输入有序，更新不易（Lucene现在使用的索引结构,内存存放前缀索引，磁盘存放后缀词块。时间复杂度O（len（str）））

|===