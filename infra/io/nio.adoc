:imagesdir: ../../static/img

== NIO(Non-blocking I/O, 在Java领域，也称为New I/O)

> 是一种同步非阻塞的I/O模型，也是I/O多路复用的基础。

=== BIO（Blocking I/O）

这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是阻塞的，当一个连接在处理I/O的时候，系统阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。

多线程的本质：

. 利用多核
. 当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。

对象是对过程的抽象，线程是对调度的抽象

多线程的问题：

* 线程的创建和销毁成本高（在linux系统中，线程本质是一个进程）创建销毁都是重量级的系统函数。
* 线程本身占用较大内存，像Java的线程栈，一般至少分配512k~1M的空间
* 线程的切换成本是很高的，需要保留上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间会大于线程执行的时间，这时候往往表现的是系统load偏高 CPU sy使用率特别高（超过20%以上），导致系统几乎陷入不可用状态。
* 容易照成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载过大。

== 常见I/O模型对比

所有系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。

需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”（通过系统中断）；而真正的读写操作的阻塞是使用CPU的，真正在“干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。


image::nio.dio.svg[]